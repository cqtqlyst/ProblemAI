{
    "topic": "Computer Science",
    "difficulty": 5,
    "limitations": "No problems involving advanced calculus",
    "format": {
      "algorithmsProblems": 3,
      "dataStructuresProblems": 2,
      "programmingProblems": 2,
      "machineLearningProblems": 1
    },
    "problems": [
      {
        "type": "word",
        "problem": "Implement the Dijkstra's algorithm to find the shortest path from node A to node E in the following weighted graph:",
        "solution": "Dijkstra's algorithm is a famous shortest-path algorithm that finds the shortest path from a starting node to all other nodes in a weighted graph. Here's the implementation of Dijkstra's algorithm for the given graph:\n\n```python\nfrom collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances\n\n# Weighted graph representation as an adjacency list\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1, 'E': 3},\n    'D': {'B': 5, 'C': 1, 'E': 2},\n    'E': {'C': 3, 'D': 2}\n}\n\nstart_node = 'A'\nshortest_paths = dijkstra(graph, start_node)\nprint(shortest_paths)\n```\n\nThe code represents the weighted graph as an adjacency list. The `dijkstra` function finds the shortest paths from the starting node `A` to all other nodes in the graph and returns a dictionary with the shortest distances. The shortest paths from node `A` to nodes `B`, `C`, `D`, and `E` are stored in the dictionary, respectively."
      },
      {
        "type": "word",
        "problem": "Implement a binary search tree (BST) in Python and write a function to check if it is a valid BST.",
        "solution": "A binary search tree (BST) is a binary tree where each node has at most two children, and the left child is less than the parent, while the right child is greater than the parent. Here's the Python code to implement a BST and check if it is a valid BST:\n\n```python\nclass TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\ndef insert(root, value):\n    if root is None:\n        return TreeNode(value)\n    if value < root.value:\n        root.left = insert(root.left, value)\n    else:\n        root.right = insert(root.right, value)\n    return root\n\n\ndef is_valid_bst(root, min_value=float('-inf'), max_value=float('inf')):\n    if root is None:\n        return True\n    if root.value <= min_value or root.value >= max_value:\n        return False\n    return is_valid_bst(root.left, min_value, root.value) and is_valid_bst(root.right, root.value, max_value)\n\n\n# Create a BST\nbst_root = None\nelements = [5, 3, 7, 2, 4, 6, 8]\nfor elem in elements:\n    bst_root = insert(bst_root, elem)\n\n\n# Check if it's a valid BST\nis_valid = is_valid_bst(bst_root)\nprint(is_valid)  # Output: True\n```\n\nThe code defines a `TreeNode` class to represent the nodes of the binary search tree. The `insert` function is used to insert elements into the BST. The `is_valid_bst` function checks if the given tree is a valid BST by recursively checking the constraints for each node. The BST is constructed using the `insert` function, and the `is_valid_bst` function is then called to check if it's a valid BST."
      },
      {
        "type": "word",
        "problem": "Write a Java program to find the longest common subsequence (LCS) between two strings.",
        "solution": "The longest common subsequence (LCS) problem is a classic dynamic programming problem. Here's the Java code to find the LCS between two strings:\n\n```java\npublic class LongestCommonSubsequence {\n    public static String findLCS(String s1, String s2) {\n        int m = s1.length();\n        int n = s2.length();\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        // Reconstruct the LCS\n        StringBuilder lcs = new StringBuilder();\n        int i = m, j = n;\n        while (i > 0 && j > 0) {\n            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                lcs.insert(0, s1.charAt(i - 1));\n                i--;\n                j--;\n            } else {\n                if (dp[i - 1][j] > dp[i][j - 1]) {\n                    i--;\n                } else {\n                    j--;\n                }\n            }\n        }\n\n        return lcs.toString();\n    }\n\n    public static void main(String[] args) {\n        String s1 = \"AGGTAB\";\n        String s2 = \"GXTXAYB\";\n        String lcs = findLCS(s1, s2);\n        System.out.println(\"Longest Common Subsequence: \" + lcs); // Output: \"GTAB\"\n    }\n}\n```\n\nThe code uses a two-dimensional array `dp` to store the lengths of the LCS for each prefix of the two strings. The `findLCS` method calculates the LCS and then reconstructs it by tracing back through the `dp` table. The final LCS is returned as a string."
      },
      {
        "type": "word",
        "problem": "Write a Python program to implement the merge sort algorithm to sort the following array of integers in non-decreasing order: [38, 27, 43, 3, 9, 82, 10]",
        "solution": "Merge sort is an efficient divide-and-conquer sorting algorithm. Here's the Python implementation of the merge sort algorithm to sort the given array:\n\n```python\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n    return merge(left_half, right_half)\n\n\ndef merge(left, right):\n    result = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            result.append(left[left_index])\n            left_index += 1\n        else:\n            result.append(right[right_index])\n            right_index += 1\n\n    result.extend(left[left_index:])\n    result.extend(right[right_index:])\n    return result\n\n\n# Test the merge sort function\narr = [38, 27, 43, 3, 9, 82, 10]\nsorted_arr = merge_sort(arr)\nprint(sorted_arr)  # Output: [3, 9, 10, 27, 38, 43, 82]\n```\n\nThe `merge_sort` function recursively divides the array into two halves and then merges them in sorted order using the `merge` function. The `merge` function merges two sorted arrays into a single sorted array. The final sorted array is obtained by repeatedly dividing and merging the original array until it is completely sorted."
      },
      {
        "type": "word",
        "problem": "Implement a Python class for a singly linked list with methods to add a node at the end, delete a node by value, and display the list.",
        "solution": "A singly linked list is a linear data structure where each element (node) contains data and a reference to the next node in the sequence. Here's the Python class implementation for a singly linked list with methods to append nodes, delete nodes by value, and display the list:\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass SinglyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if self.head is None:\n            self.head = new_node\n        else:\n            current = self.head\n            while current.next is not None:\n                current = current.next\n            current.next = new_node\n\n    def delete(self, value):\n        if self.head is None:\n            return\n        if self.head.data == value:\n            self.head = self.head.next\n            return\n        current = self.head\n        while current.next is not None:\n            if current.next.data == value:\n                current.next = current.next.next\n                return\n            current = current.next\n\n    def display(self):\n        elements = []\n        current = self.head\n        while current is not None:\n            elements.append(current.data)\n            current = current.next\n        print(' -> '.join(map(str, elements)))\n\n\n# Test the SinglyLinkedList class\nsll = SinglyLinkedList()\nsll.append(10)\nsll.append(20)\nsll.append(30)\n\nprint(\"Linked list:\")\nsll.display()  # Output: 10 -> 20 -> 30\n\nsll.delete(20)\nprint(\"After deleting 20:\")\nsll.display()  # Output: 10 -> 30\n```\n\nThe `Node` class represents each node in the linked list. The `SinglyLinkedList` class manages the linked list and provides methods to append nodes, delete nodes by value, and display the list."
      },
      {
        "type": "word",
        "problem": "What is the time complexity of the quicksort algorithm?",
        "solution": "The time complexity of the quicksort algorithm is O(n log n) on average. Quicksort is a divide-and-conquer sorting algorithm that works by selecting a 'pivot' element and partitioning the array around the pivot. The average-case time complexity is O(n log n) because the algorithm divides the input into roughly equal-sized partitions during each recursive call, and the partitioning step can be done in O(n) time.\n\nHowever, the worst-case time complexity of quicksort is O(n^2), which occurs when the pivot selection consistently results in poorly balanced partitions. To mitigate this, randomized pivot selection or other optimization techniques are often used.\n\nDespite the worst-case scenario, quicksort is generally considered one of the most efficient sorting algorithms due to its average-case time complexity and low overhead. Its performance is often comparable to other efficient sorting algorithms like merge sort and heapsort."
      }
    ]
  }
  